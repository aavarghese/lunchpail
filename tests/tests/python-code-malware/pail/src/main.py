# (C) Copyright IBM Corp. 2024.
# Licensed under the Apache License, Version 2.0 (the “License”);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#  http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an “AS IS” BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

import subprocess
import time
from argparse import ArgumentParser, Namespace
from io import BytesIO
from typing import Any

import pyarrow as pa

INPUT_COLUMN_KEY = "malware_input_column"
OUTPUT_COLUMN_KEY = "malware_output_column"
DEFAULT_INPUT_COLUMN = "contents"
DEFAULT_OUTPUT_COLUMN = "virus_detection"
CLAMD_TIMEOUT_SEC = 180
INIT_TIMEOUT_SEC = 60

def add_column(table: pa.Table, name: str, content: list[Any]) -> pa.Table:
    """
    Add column to the table
    :param table: original table
    :param name: column name
    :param content: content of the column
    :return: updated table, containing new column
    """
    # check if column already exist and drop it
    if name in table.schema.names:
        table = table.drop(columns=[name])
    # append column
    return table.append_column(field_=name, column=[content])
    
# def check_clamd():
#     logger = get_logger(__name__)
#     cd = clamd.ClamdUnixSocket()
#     check_end = time.time() + INIT_TIMEOUT_SEC
#     while True:
#         try:
#             cd.ping()
#             break
#         except Exception as err:
#             if time.time() < check_end:
#                 logger.debug("waiting until clamd is ready...")
#                 time.sleep(1)
#             else:
#                 logger.error(
#                     f"clamd didn't become ready in {INIT_TIMEOUT_SEC} sec. Please check if clamav container is running."
#                 )
#                 raise err
#     del cd


def check_clamd(logger: logging.Logger):
    import clamd

    cd = clamd.ClamdUnixSocket()
    check_end = time.time() + INIT_TIMEOUT_SEC
    while True:
        try:
            cd.ping()
            break
        except Exception as err:
            if time.time() < check_end:
                logger.debug("waiting until clamd is ready...")
                time.sleep(1)
            else:
                logger.error(
                    f"clamd didn't become ready in {INIT_TIMEOUT_SEC} sec. Please check if clamav container is running."
                )
                raise err
    del cd

"""
Initialize based on the dictionary of configuration information.
This is generally called with configuration parsed from the CLI arguments defined
by the companion runtime, MalwareTransformRuntime.  If running inside the RayMutatingDriver,
these will be provided by that class with help from the RayMutatingDriver.
"""
import clamd

# Make sure that the param name corresponds to the name used in apply_input_params method
# of MalwareTransformConfiguration class

warning_issued = False
input_column = config.get(INPUT_COLUMN_KEY, DEFAULT_INPUT_COLUMN)
output_column = config.get(OUTPUT_COLUMN_KEY, DEFAULT_OUTPUT_COLUMN)
# Check local clamd process is running
cd = clamd.ClamdUnixSocket()
try:
    cd.ping()
except clamd.ConnectionError:
    print("Clamd process is not running. Start clamd process.")
    subprocess.Popen("clamd", shell=True)
    # Wait for starting up clamd
    timeout = time.time() + CLAMD_TIMEOUT_SEC
    while True:
        try:
            cd.ping()
            break
        except clamd.ConnectionError as err:
            if time.time() < timeout:
                print("Clamd is not ready. Retry after 5 seconds.")
                time.sleep(5)
            else:
                print(f"Clamd didn't become ready in {CLAMD_TIMEOUT_SEC} seconds.")
                raise err
del cd

def transform(table: pa.Table, file_name: str = None) -> tuple[list[pa.Table], dict[str, Any]]:
    """
    Put Transform-specific to convert one Table to 0 or more tables. It also returns
    a dictionary of execution statistics - arbitrary dictionary
    This implementation makes no modifications so effectively implements a copy of the
    input parquet to the output folder, without modification.
    """
    import clamd

    print(f"Transforming one table with {len(table)} rows")

    cd = clamd.ClamdUnixSocket()

    def _scan(content: str) -> str | None:
        if content is None:
            return None
        (status, description) = cd.instream(BytesIO(content.encode()))["stream"]
        if status == "FOUND":
            print(f"Detected: {description}")
            return description or "UNKNOWN"
        return None

    virus_detection = pa.array(list(map(_scan, table[input_column].to_pylist())), type=pa.string())

    nrows = table.num_rows
    clean = virus_detection.null_count
    infected = nrows - clean
    table = add_column(table, output_column, virus_detection)
    # Add some sample metadata.
    print(f"Virus detection {infected} / {nrows} rows")
    metadata = {"clean": clean, "infected": infected}
    return [table], metadata
